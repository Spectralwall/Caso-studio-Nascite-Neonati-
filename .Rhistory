log(Cranio)+
Tipo.parto+
Sesso,
data=neonati.filtrato)
summary(mod9)
par(mfrow=c(2,2))
plot(mod9,id.n = 10)
#ci sono degli outliars che fatto leva sul modello
#Rieseguiamo i test
#test di normalita --> ipotes di normalita
shapiro.test(residuals(mod9))
#test di Omoschedasticità --> ipotesi di omoschedacita
bptest(mod9)
#test di incorellazione
dwtest(mod9)
#il modello risulta eterostecastico e non normale
#per valutare sia leverers che outliars abbiamo la distanza di cook
cook<-cooks.distance(mod9)
# Cook's distance
par(mfrow=c(1,1))
plot(mod9, 5, id.n = 5)
plot(mod9, 4, id.n = 5)
max(cook)
#individuiamo valori che hanno distanza di cook molto alta e eliminiamoli
influential <- cook[(cook > (3 * mean(cook, na.rm = TRUE)))]
names_of_influential <- names(influential)
influential
neonati.filtrato <- neonati.filtrato %>% anti_join(neonati.filtrato[names_of_influential,])
summary(mod9)
mod9<- lm(log(Peso)~
N.gravidanze+
log(Gestazione)+
log(Lunghezza)+
log(Cranio)+
Tipo.parto+
Sesso,
data=neonati.filtrato)
summary(mod9)
#togliamo altri outliars
#per valutare sia leverers che outliars abbiamo la distanza di cook
cook<-cooks.distance(mod9)
influential <- cook[(cook > (10 * mean(cook, na.rm = TRUE)))]
names_of_influential <- names(influential)
influential
neonati.filtrato <- neonati.filtrato %>% anti_join(neonati.filtrato[names_of_influential,])
test <- data.frame(N.gravidanze = 3,Gestazione=39)
test
predict(mod9, newdata = test)
mod9<- lm(log(Peso)~
N.gravidanze+
log(Gestazione)+
log(Lunghezza)+
log(Cranio)+
Tipo.parto+
Sesso,
data=neonati.filtrato)
summary(mod9)
#togliamo altri outliars
#per valutare sia leverers che outliars abbiamo la distanza di cook
cook<-cooks.distance(mod9)
influential <- cook[(cook > (10 * mean(cook, na.rm = TRUE)))]
names_of_influential <- names(influential)
influential
plot(mod9, 5, id.n = 5)
plot(mod9, 4, id.n = 5)
test <- data.frame(N.gravidanze = 3,Gestazione=39)
mod9<- lm(log(Peso)~
N.gravidanze+
log(Gestazione)+
log(Lunghezza)+
log(Cranio)+
Tipo.parto+
Sesso,
data=neonati.filtrato)
summary(mod9)
#proviamo ora a cambiare lo standard error con il robust standard error, per risolvere
coeftest(mod9, vcov = vcovHC(mod9, "HC1"))
myalvm <- alvm.fit(mod9, model = "linear")
library(skedastic)
myalvm <- alvm.fit(mod9, model = "linear")
myalvm
summary(myalvm)
summary(myalvm.ols)
summary(myalvm$ols)
summary(mod9)
par(mfrow=c(2,2))
plot(myalvm$ols,id.n = 10)
shapiro.test(residuals(myalvm$ols))
#test di Omoschedasticità --> ipotesi di omoschedacita
bptest(myalvm$ols)
#test di incorellazione
dwtest(myalvm$ols)
#test di Omoschedasticità --> ipotesi di omoschedacita
bptest(mod9)
summary(mod9)
mod9<- lm(log(Peso)~
N.gravidanze+
log(Gestazione)+
log(Lunghezza)+
log(Cranio)+
Sesso,
data=neonati.filtrato)
summary(mod9)
#test di Omoschedasticità --> ipotesi di omoschedacita
bptest(mod9)
#test di incorellazione
dwtest(mod9)
#test di Omoschedasticità --> ipotesi di omoschedacita
bptest(mod9)
mod9<- lm(log(Peso)~
N.gravidanze+
log(Gestazione)+
log(Lunghezza)+
log(Cranio)+
Tipo.parto+
Sesso,
data=neonati.filtrato)
#test di Omoschedasticità --> ipotesi di omoschedacita
bptest(mod9)
#Rieseguiamo i test
#test di normalita --> ipotes di normalita
shapiro.test(residuals(mod9))
mod9<- lm(log(Peso)~
N.gravidanze+
log(Gestazione)+
log(Lunghezza)+
log(Cranio)+
Sesso,
data=neonati.filtrato)
#Rieseguiamo i test
#test di normalita --> ipotes di normalita
shapiro.test(residuals(mod9))
mod9<- lm(log(Peso)~
N.gravidanze+
log(Gestazione)+
log(Lunghezza)+
log(Cranio)+
Tipo.parto+
Sesso,
data=neonati.filtrato)
#Rieseguiamo i test
#test di normalita --> ipotes di normalita
shapiro.test(residuals(mod9))
N.gravidanze+
log(Gestazione)+
log(Lunghezza)+
log(Cranio)+
Tipo.parto+
Sesso,
test <- data.frame(N.gravidanze = 3,Gestazione=39,Lunghezza=0,Cranio=0,Tipo.parto=NaN,Sesso=NaN)
test
predict(mod9, newdata = test)
test <- data.frame(N.gravidanze = 3,Gestazione=39,Lunghezza=0,Cranio=0,Tipo.parto="NaN",Sesso="NaN")
predict(mod9, newdata = test)
#creiamo un dataset secondario per togliere i dati non numerici
neonati.numeric <- neonati.filtrato
neonati.numeric$Tipo.parto <- ifelse(neonati.filtrato$Tipo.parto=="Nat",1,0)
neonati.numeric$Sesso <- ifelse(neonati.filtrato$Sesso=="M",1,0)
neonati.numeric$Ospedale <- ifelse(neonati.filtrato$Ospedale=="osp1",1,
ifelse(neonati.filtrato$Ospedale=="osp2",2,3))
mod9<- lm(log(Peso)~
N.gravidanze+
log(Gestazione)+
log(Lunghezza)+
log(Cranio)+
Tipo.parto+
Sesso,
data=neonati.numeric)
summary(mod9)
par(mfrow=c(2,2))
plot(mod9,id.n = 10)
plot(mod9,id.n = 10)
#Rieseguiamo i test
#test di normalita --> ipotes di normalita
shapiro.test(residuals(mod9))
#test di Omoschedasticità --> ipotesi di omoschedacita
bptest(mod9)
#test di incorellazione
dwtest(mod9)
mod9<- lm(log(Peso)~
N.gravidanze+
log(Gestazione)+
log(Lunghezza)+
log(Cranio)+
Tipo.parto+
Sesso,
data=neonati.filtrato)
summary(mod9)
table(Tipo.parto)
test <- data.frame(N.gravidanze = 3,Gestazione=39,Lunghezza=0,Cranio=0,Tipo.parto="Nat",Sesso="F")
test
predict(mod9, newdata = test)
mean(Lunghezza)
median(Lunghezza)
500
median(Cranio)
test <- data.frame(N.gravidanze = 3,Gestazione=39,Lunghezza=500,Cranio=340,Tipo.parto="Nat",Sesso="F")
test
predict(mod9, newdata = test)
test <- data.frame(N.gravidanze = 3,Gestazione=log(39),Lunghezza=500,Cranio=340,Tipo.parto="Nat",Sesso="F")
test
predict(mod9, newdata = test)
test <- data.frame(N.gravidanze = 3,Gestazione=39,Lunghezza=500,Cranio=340,Tipo.parto="Nat",Sesso="F")
predict(mod9, newdata = test)
e^8.111292
exp(1)
exp(predict(mod9, newdata = test))
avPlots(mod9)
mean(Lunghezza)
testMedian <- data.frame(N.gravidanze = 3,Gestazione=39,Lunghezza=500,Cranio=340,Tipo.parto="Nat",Sesso="F")
testMedian
mean(Cranio)
testMean <- data.frame(N.gravidanze = 3,Gestazione=39,Lunghezza=494.6958,Cranio=340.0292,Tipo.parto="Nat",Sesso="F")
testMean
exp(predict(mod9, newdata = testMean))
exp(predict(mod9, newdata = testMedian))
exp(predict(mod9, newdata = testMean))
summary(mod9)
rmse <- sqrt(sum((exp(pred1) - testMedian$Peso)^2)/length(testMedian$Peso))
#facciamo delle predizioni
pred1 = exp(predict(mod9, newdata = testMedian))
rmse <- sqrt(sum((exp(pred1) - testMedian$Peso)^2)/length(testMedian$Peso))
c(RMSE = rmse, R2=summary(model4)$r.squared)
c(RMSE = rmse, R2=summary(mod9)$r.squared)
ANALISI NASCITE NEONATI
#ANALISI NASCITE NEONATI
#IMPORT
library(moments)
library(ggplot2)
library(gridExtra)
library(grid)
library(ggthemes)
library(PerformanceAnalytics)
library(knitr)
library(magrittr)
library(corrplot)
library(car)
library(lmtest)
library(sandwich)
library(estimatr)
library(dplyr)
library(skedastic)
#FUNZIONI
#Funzione che calcola la moda/classe modale
Mode <- function(x) {
ux <- unique(x)
ux[which.max(tabulate(match(x, ux)))]
}
#COEFFIECENTE DI VARIAZIONE
CV <- function(x){
return((sd(x)/mean(x))*100)
}
#INDICE DI ETEROGENEITA DI GINI Normalizzato
G <- function(x){
ni=table(x) #frequenze assolute
fi=ni/length(x)#frequenze relative
fi2 = fi^2 #frequenze relative al quadrato
J = length(table(x)) #tipi di classi che abbiamo
gini = 1-sum(fi2) #G=1-sommatoria di frequenze relative al quadrato
gini_norm = gini/((J-1)/J)
return(gini_norm)
}
#funzione che data una variabile quantitava divisa in classi calcola la distribuzione assoluta
distribuzione_assoluta <- function(x){
n=length(x)
ni=table(x)
fi=table(x)/n
Ni=cumsum(table(x))
Fi=cumsum(table(x))/n
return(as.data.frame(cbind(ni,fi,Ni,Fi)))
}
#funzione che genera una tabella contenente tutti gli indici di una variabile
#indici di posizione, variabilità e forma
analisi.quantitative <- function(x,y,z){
df=as.data.frame(cbind(summary(x)))
colnames(df)<-c(y)
df2=data.frame(summary=c(max(x)-min(x),IQR(x),Mode(x),var(x),
sd(x),CV(x),skewness(x),kurtosis(x)-3))
rownames(df2) <- c("Range","IQR","Mode","Var","SD","CV","Asymmetry","Curtosi")
colnames(df2)<-c(y)
df_all = rbind(df,df2)
png("report.png", height = 24*nrow(df_all), width = 215*ncol(df_all))
grid.table(df_all)
dev.off()
plot=ggplot()+
geom_density(aes(x=x),col="darkblue",fill="lightblue")+
geom_vline(aes(xintercept=mean(x)),
color="red", linetype="dashed", linewidth=1)+
geom_vline(aes(xintercept=quantile(x,seq(0,1,0.25))),
color="green3", linetype="dashed", linewidth=1)+
geom_vline(aes(xintercept=median(x)),
color="orange", linetype="dashed", linewidth=1)+
geom_vline(aes(xintercept=Mode(x)),
color="yellow", linetype="dashed", linewidth=1)+
xlab("Sales")+
ylab("Density")+
labs(title = c(z))+
theme_fivethirtyeight()
print("Distribuzione, Summary, Range, Range Interquantile, Moda, Variaza, Devizione standard, Coefficente di variazione, Assiemtria, Curtosi")
return(
list(
plot,
summary(x),
max(x)-min(x),
IQR(x),
Mode(x),
var(x),
sd(x),
CV(x),
skewness(x),
kurtosis(x)-3
)
)
}
#funzione che fa un analisi compleata delle variabili quantitative
#esegue tabelle di frequenza assoluta, relativa, cumulata e indice di gini
analisi.qualitative <- function(x){
n=length(x)
ni=table(x)
fi=table(x)/n
Ni=cumsum(table(x))
Fi=cumsum(table(x))/n
df=as.data.frame(cbind(ni,fi,Ni,Fi))
png("Frequenze.png", height = 50*nrow(df), width = 100*ncol(df))
grid.table(df)
dev.off()
png("Gini.png", height = 50*nrow(df), width = 50*ncol(df))
grid.table(data.frame(Gini=c(G(x))))
dev.off()
}
#funzione che data una variabile quantitativa e una sequenza di valori
#divide la variabile in classi e stampa un grafico a barre
analisi.classi <- function(x,y){
classi = cut(x,y)#divisa in 7 classi da 1 centimetro l'uno
df_freq = distribuzione_assoluta(classi)
ggplot(data=df_freq, aes(x=reorder(row.names(df_freq), +fi), y=ni,fill=row.names(df_freq))) +
geom_bar(stat="identity")+
labs(title="Distribuzione in classi",
x="Classi",
y="Frequenza")+
theme_fivethirtyeight()+
theme(axis.title = element_text())+
guides(fill=guide_legend(title="Classi"))
}
format(1000, scientific = TRUE)
#import dataset
#se computer portatile
setwd("C:\\Users\\gabri\\Desktop\\PrivateProject\\Caso-studio-Nascite-Neonati-")
neonati <- read.csv("neonati.csv",stringsAsFactors = T)
attach(neonati)
head(neonati)
summary(neonati)
#Analisi variabili
#Anni madre---------------------------------------------------------------------
summary(neonati$Anni.madre)
table(neonati$Anni.madre)#ci sono due valori fuori scala
detach(neonati)
#rimuoviamo dal dataset tutte le registrazioni in cui gli anni della madre sono minori di 12
#di solito la possibilià di rimanere incinete avviene in concomitanza con l'inzio il primo ciclo che è intorno al 12 anno di età
neonati.filtrato <- subset(neonati,Anni.madre>=12)
attach(neonati.filtrato)
#prima di inizare a creare i modelli dividiamo il dataset in training e test set
head(neonati.filtrato)
#prima di inizare a creare i modelli dividiamo il dataset in training e test set
sample <- sample(c(TRUE, FALSE), nrow(neonati.filtrato), replace=TRUE, prob=c(0.9,0.1))
head(sample)
train  <- df[sample, ]
train  <- df[sample, ]
#prima di inizare a creare i modelli dividiamo il dataset in training e test set
neonati.filtrato$id <- 1:nrow(neonati.filtrato)
head(neonati.filtrato)
#use 70% of dataset as training set and 30% as test set
train <- neonati.filtrato %>% dplyr::sample_frac(0.80)
test  <- dplyr::anti_join(neonati.filtrato, train, by = 'id')
View(test)
View(neonati.filtrato)
#prima di inizare a creare i modelli dividiamo il dataset in training e test set
neonati.filtrato$id <- 1:nrow(neonati.filtrato)
#use 70% of dataset as training set and 30% as test set
train <- neonati.filtrato %>% dplyr::sample_frac(0.95)
test  <- dplyr::anti_join(neonati.filtrato, train, by = 'id')
test
head(test)
#ma ce un problema nello studio di queste variabili,aho paura che alcune siano troppo correlate e diano problemi di multicollinearita
#mqa verifichiamolo, costruiamo un modello
mod1<- lm(Peso~
Anni.madre+
N.gravidanze+
Gestazione+
Lunghezza+
Cranio+
Fumatrici+
Tipo.parto+
Ospedale+
Sesso,
data=train)
summary(mod1)
#da tutti i test ci risulta che la rimuzione di Anni.madre e Fumatrici non fa modificare la qualita del modello
#facciamo un ultimo test, creando un modello in cui evidenziamo che peso,lunghezza,circonferenza e gestazione anno crescita logaritmica
mod5<- lm(I(log(Peso))~
N.gravidanze+
I(log(Gestazione))+
I(log(Lunghezza))+
I(log(Cranio))+
Tipo.parto+
Sesso,
data=train)
summary(mod5)
mod9<- lm(log(Peso)~
N.gravidanze+
log(Gestazione)+
log(Lunghezza)+
log(Cranio)+
Tipo.parto+
Sesso,
data=train)
summary(mod9)
par(mfrow=c(2,2))
plot(mod9,id.n = 10)
#Rieseguiamo i test
#test di normalita --> ipotes di normalita
shapiro.test(residuals(mod9))
#test di Omoschedasticità --> ipotesi di omoschedacita
bptest(mod9)
#test di incorellazione
dwtest(mod9)
#per valutare sia leverers che outliars abbiamo la distanza di cook
cook<-cooks.distance(mod9)
# Cook's distance
par(mfrow=c(1,1))
plot(mod9, 5, id.n = 5)
plot(mod9, 4, id.n = 5)
max(cook)
#individuiamo valori che hanno distanza di cook molto alta e eliminiamoli
influential <- cook[(cook > (3 * mean(cook, na.rm = TRUE)))]
names_of_influential <- names(influential)
influential
train <- train %>% anti_join(train[names_of_influential,])
mod9<- lm(log(Peso)~
N.gravidanze+
log(Gestazione)+
log(Lunghezza)+
log(Cranio)+
Tipo.parto+
Sesso,
data=train)
summary(mod9)
#Rieseguiamo i test
#test di normalita --> ipotes di normalita
shapiro.test(residuals(mod9))
#test di Omoschedasticità --> ipotesi di omoschedacita
bptest(mod9)
#test di incorellazione
dwtest(mod9)
cook<-cooks.distance(mod9)
influential <- cook[(cook > (10 * mean(cook, na.rm = TRUE)))]
names_of_influential <- names(influential)
influential
train <- train %>% anti_join(train[names_of_influential,])
mod9<- lm(log(Peso)~
N.gravidanze+
log(Gestazione)+
log(Lunghezza)+
log(Cranio)+
Tipo.parto+
Sesso,
data=train)
summary(mod9)
#Rieseguiamo i test
#test di normalita --> ipotes di normalita
shapiro.test(residuals(mod9))
#test di Omoschedasticità --> ipotesi di omoschedacita
bptest(mod9)
#test di incorellazione
dwtest(mod9)
#proviamo ora a cambiare lo standard error con il robust standard error, per risolvere
coeftest(mod9, vcov = vcovHC(mod9, "HC1"))
summary(mod9)
#creiamo degli esempi fittizi
testMedian <- data.frame(N.gravidanze = 3,Gestazione=39,Lunghezza=500,Cranio=340,Tipo.parto="Nat",Sesso="F")
testMean <- data.frame(N.gravidanze = 3,Gestazione=39,Lunghezza=494.6958,Cranio=340.0292,Tipo.parto="Nat",Sesso="F")
#facciamo delle predizioni
pred1 = exp(predict(mod9, newdata = testMedian))
rmse <- sqrt(sum((exp(predMedian) - testMedian$Peso)^2)/length(testMedian$Peso))
#facciamo delle predizioni
predMedian = exp(predict(mod9, newdata = testMedian))
rmse <- sqrt(sum((exp(predMedian) - testMedian$Peso)^2)/length(testMedian$Peso))
c(RMSE = rmse, R2=summary(mod9)$r.squared)
exp(predict(mod9, newdata = testMean))
predMean = exp(predict(mod9, newdata = testMean))
rmse <- sqrt(sum((exp(predMean) - testMean$Peso)^2)/length(testMean$Peso))
c(RMSE = rmse, R2=summary(mod9)$r.squared)
rmse <- sqrt(sum((exp(predMean) - testMean$Peso)^2)/length(testMean$Peso))
c(RMSE = rmse, R2=summary(mod9)$r.squared)
rmse
#facciamo delle predizioni
predMedian = predict(mod9, newdata = testMedian)
predMean = predict(mod9, newdata = testMean)
exp(predMedian)
exp(predMean)
rmse <- sqrt(sum((exp(predMedian) - testMedian$Peso)^2)/length(testMedian$Peso))
rmse
rmse <- sqrt(sum((exp(predMedian) - testMedian$Peso)^2)/length(testMedian$Peso))
rmse
c(RMSE = rmse, R2=summary(mod9)$r.squared)
predictionTest = predict(mod9, newdata = test)
rmse <- sqrt(sum((exp(predictionTest) - test$Peso)^2)/length(test$Peso))
rmse
c(RMSE = rmse, R2=summary(mod9)$r.squared)
plot(mod9, 5, id.n = 5)
plot(mod9, 4, id.n = 5)
c(RMSE = rmse, R2=summary(mod9)$r.squared)
